<!DOCTYPE html>
<html>
<head>
<title>README_ALL.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="js-leetcode">js-leetcode</h1>
<p>Just answers and flow charts for various leetcode questions.</p>
<h2 id="example-with-gitbook-plugin">Example with gitbook plugin</h2>
<p>This is an exercise:</p>
<hr>
<p>Define a variable <code>x</code> equal to 10.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> x =
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
</div></code></pre>
<pre class="hljs"><code><div>assert(x == <span class="hljs-number">10</span>);
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// This is context code available everywhere</span>
<span class="hljs-comment">// The user will be able to call magicFunc in his code</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">magicFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}
</div></code></pre>
<hr>
<h2 id="0---examplesadd-binaryjs">0 - ./examples/add-binary.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> addBinary = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">var</span> [carry, i, j, res] = [<span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>, b.length - <span class="hljs-number">1</span>, <span class="hljs-string">""</span>];
    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> bita = i &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">Number</span>(a[i]) : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> bitb = j &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">Number</span>(b[j]) : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> sum = bita + bitb + carry;
        res = <span class="hljs-string">`<span class="hljs-subst">${sum%<span class="hljs-number">2</span>}</span><span class="hljs-subst">${res}</span>`</span>;
        carry = <span class="hljs-built_in">Math</span>.floor(sum / <span class="hljs-number">2</span>);
        i--; j--;
    }
    <span class="hljs-keyword">return</span> res;
  };
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/add-binary.svg" alt="./examples/add-binary.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="1---examplesarray-3-sum-equal-zerojs">1 - ./examples/array-3-sum-equal-zero.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumToZero</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">if</span> (!arr) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>

    arr.sort();
    <span class="hljs-keyword">let</span> n = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//loop each item</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//right of i</span>
        <span class="hljs-keyword">let</span> k = n; <span class="hljs-comment">//end of arr</span>
        <span class="hljs-keyword">while</span> (k &gt; j) {
            count++;
            sum = arr[i] + arr[j] + arr[k];
            <span class="hljs-built_in">console</span>.log(i, j, k, sum);
            
            <span class="hljs-comment">//found match...done</span>
            <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Found sum at'</span>, i, j, k, <span class="hljs-string">`(<span class="hljs-subst">${arr[i]}</span> + <span class="hljs-subst">${arr[j]}</span> + <span class="hljs-subst">${arr[k]}</span>)`</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-comment">// We didn't match. Let's try to get a little closer:</span>
            <span class="hljs-comment">//   If the sum was too big, decrement k.</span>
            <span class="hljs-comment">//   If the sum was too small, increment j.</span>
            sum &gt; <span class="hljs-number">0</span> ? k-- : j++;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}


<span class="hljs-comment">//console.log(sumToZero([1, 1, 2, -1]));</span>
<span class="hljs-comment">//console.log(sumToZero([1, 2, 3, -3]));</span>
<span class="hljs-comment">//console.log(sumToZero([2, 1, -3, 3]));</span>
<span class="hljs-built_in">console</span>.log(sumToZero([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">6</span>]));






<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">arr</span>) </span>{
    arr.sort();
    <span class="hljs-keyword">let</span> k = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">const</span> a = arr[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) {
            <span class="hljs-keyword">const</span> b = arr[j];
            <span class="hljs-built_in">console</span>.log(a, b);
        }
    }
    
    
}
<span class="hljs-built_in">console</span>.log(threeSum([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">3</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/array-3-sum-equal-zero.svg" alt="./examples/array-3-sum-equal-zero.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="2---examplesarray-pair-sumjs">2 - ./examples/array-pair-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> arrayPairSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> hash = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20001</span>; ++i) {
        hash[i] = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Number</span>.MAX_VALUE;
    <span class="hljs-keyword">let</span> max = <span class="hljs-built_in">Number</span>.MIN_VALUE;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {
        <span class="hljs-keyword">let</span> cur = nums[i] + <span class="hljs-number">10000</span>;
        ++hash[cur];
        min = <span class="hljs-built_in">Math</span>.min(min, cur);
        max = <span class="hljs-built_in">Math</span>.max(max, cur);
    }
    <span class="hljs-keyword">let</span> evenOdd = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = min; i &lt;= max; ++i) {
        <span class="hljs-keyword">let</span> curAmount = hash[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; curAmount; ++j) {
            <span class="hljs-keyword">if</span> (evenOdd == <span class="hljs-number">0</span>) {
                sum += i - <span class="hljs-number">10000</span>;
            }
            evenOdd ^= <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> sum;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/array-pair-sum.svg" alt="./examples/array-pair-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="3---examplesarray-shufflejs">3 - ./examples/array-shuffle.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {number[]} nums
 */</span>
<span class="hljs-keyword">var</span> Solution = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">this</span>.nums = nums;
};

<span class="hljs-comment">/**
 * Resets the array to its original configuration and return it.
 * @return {number[]}
 */</span>
Solution.prototype.reset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nums;
};

<span class="hljs-comment">/**
 * Returns a random shuffling of the array.
 * @return {number[]}
 */</span>
Solution.prototype.shuffle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-comment">/* let copy = this.nums.slice();
    for (let i = 0; i &lt; copy.length; i++) {
        let rand = Math.floor(Math.random() * copy.length);
        let temp = copy[i];
        copy[i] = copy[rand];
        copy[rand] = temp;
    }
    return copy;*/</span>

    <span class="hljs-keyword">let</span> nums = [...this.nums];
    <span class="hljs-keyword">let</span> i = nums.length;

    <span class="hljs-keyword">while</span> (i--) {
      <span class="hljs-keyword">const</span> n = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * nums.length);
      [nums[i], nums[n]] = [nums[n], nums[i]];
    }

    <span class="hljs-keyword">return</span> nums;

   <span class="hljs-comment">/* let temp = [];
    this.nums.forEach((val, key) =&gt; temp[key] = val);
    for (let i = 0; i &lt; temp.length; i++) {
        let rand = Math.floor(Math.random() * (temp.length - i))
        let n = temp[i];
        temp[i] = temp[rand];
        temp[rand] = n;
    }
    
    return temp;*/</span>
};

<span class="hljs-comment">/** 
 * Your Solution object will be instantiated and called as such:
 * var obj = Object.create(Solution).createNew(nums)
 * var param_1 = obj.reset()
 * var param_2 = obj.shuffle()
 */</span>
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/array-shuffle.svg" alt="./examples/array-shuffle.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="4---examplesbest-time-to-buy-sell-stock-2js">4 - ./examples/best-time-to-buy-sell-stock-2.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// Say you have an array for which the ith element is the price of a given stock on day i.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [7,1,5,3,6,4]</span>
<span class="hljs-comment">// Output: 7</span>
<span class="hljs-comment">// Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span>
<span class="hljs-comment">// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [1,2,3,4,5]</span>
<span class="hljs-comment">// Output: 4</span>
<span class="hljs-comment">// Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span>
<span class="hljs-comment">// Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span>
<span class="hljs-comment">// engaging multiple transactions at the same time. You must sell before buying again.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 3:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [7,6,4,3,1]</span>
<span class="hljs-comment">// Output: 0</span>
<span class="hljs-comment">// Explanation: In this case, no transaction is done, i.e. max profit = 0.</span>

<span class="hljs-comment">/**
 * @param {number[]} prices
 * @return {number}
 */</span>

<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">prices</span>) </span>{
    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">const</span> diff = prices[i + <span class="hljs-number">1</span>] - prices[i];
        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) profit += diff;
    }

    <span class="hljs-keyword">return</span> profit;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/best-time-to-buy-sell-stock-2.svg" alt="./examples/best-time-to-buy-sell-stock-2.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="5---examplesbest-time-to-buy-sell-stockjs">5 - ./examples/best-time-to-buy-sell-stock.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// Say you have an array for which the ith element is the price of a given stock on day i.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note that you cannot sell a stock before you buy one.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [7,1,5,3,6,4]</span>
<span class="hljs-comment">// Output: 5</span>
<span class="hljs-comment">// Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span>
<span class="hljs-comment">// Not 7-1 = 6, as selling price needs to be larger than buying price.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [7,6,4,3,1]</span>
<span class="hljs-comment">// Output: 0</span>
<span class="hljs-comment">// Explanation: In this case, no transaction is done, i.e. max profit = 0.</span>

<span class="hljs-comment">/**
 * @param {number[]} prices
 * @return {number}
 */</span>

<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">prices</span>) </span>{
    <span class="hljs-keyword">let</span> min = <span class="hljs-literal">Infinity</span>;
    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length - <span class="hljs-number">1</span>; i++) {
        min = <span class="hljs-built_in">Math</span>.min(min, prices[i]);
        max = <span class="hljs-built_in">Math</span>.max(max, prices[i + <span class="hljs-number">1</span>] - min)
    }

    <span class="hljs-keyword">return</span> max;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/best-time-to-buy-sell-stock.svg" alt="./examples/best-time-to-buy-sell-stock.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="6---examplesbig-ojs">6 - ./examples/big-o.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Big-O Analysis

Big-O analysis is a form of runtime analysis that measures the efficiency of an algorithm in terms of the time it takes for the algorithm to run as a function of the input size. It’s not a formal benchmark, just a simple way to classify algorithms by relative efficiency when dealing with very large input sizes.
How Big-O Analysis Works

In Big-O analysis, input size is assumed to be an unknown value n. In this example, n simply represents the number of elements in an array. In other problems, n may represent the number of nodes in a linked list, the number of bits in a data type, or the number of entries in a hash table. After determining what n means in terms of the input, you must determine how many operations are performed for each of the n input items. “Operation” is a fuzzy word because algorithms differ greatly.
Commonly, an operation is something that a real computer can do in a constant amount of time, like adding an input value to a constant, creating a new input item, or deleting an input value. In Big-O analysis, the times for these operations are all considered equivalent.

- In both `CompareToMax` and `CompareToAll`, the operation of greatest interest is comparing an array value to another value.

- In `CompareToMax`, each array element was compared once to a maximum value. Thus, the n input items are each examined once, resulting in n examinations. 
This is considered O(n), usually referred to as linear time: The time required to run the algorithm increases linearly with the number of input items.
How to Do Big-O Analysis

The general procedure for Big-O runtime analysis is as follows:

1. Figure out what the input is and what n represents.
2. Express the number of operations the algorithm performs in terms of n.
3. Eliminate all but the highest-order terms.
4. Remove all constant factors.

For the algorithms you’ll encounter in interviews, Big-O analysis should be straightforward as long as you correctly identify the operations that are dependent on the input size.
Which is Better?

The performance of most algorithms depends on n, the size of the input. The algorithms can be classified as follows from best-to-worse performance:

* O(log n) — An algorithm is said to be logarithmic if its running time increases logarithmically in proportion to the input size.
* O(n) — A linear algorithm’s running time increases in direct proportion to the input size.
* O(n log n) — A superlinear algorithm is midway between a linear algorithm and a polynomial algorithm.
* O(nc) — A polynomial algorithm grows quickly based on the size of the input.
* O(cn) — An exponential algorithm grows even faster than a polynomial algorithm.
* O(n!) — A factorial algorithm grows the fastest and becomes quickly unusable for even small values of n.

The run times of different orders of algorithms separate rapidly as n gets larger. 

Consider the run time for each of these algorithm classes with n = 10:

* log 10 = 1
* 10 = 10
* 10 log 10 = 10
* 102 = 100
* 210= 1,024
* 10! = 3,628,800

Now double it to n = 20:

* log 20 = 1.30
* 20 = 20
* 20 log 20= 26.02
* 202 = 400
* 220 = 1,048,576
* 20! = 2.43×1018

Notation
Name
O(1)
Constant
O(log(n))
Logarithmic
O((log(n))c)
Poly-logarithmic
O(n)
Linear
O(n2)
Quadratic
O(nc)
Polynomial
O(cn)
Exponential


### [] O(1)

Consider the following function:

function increment(num){ 
  return ++num; 
}

[]O(N)

Now, let's use the sequential search algorithm:

function sequentialSearch(array, item){ 
  for (var i=0; i&lt;array.length; i++){ 
    if (item === array[i]){ //{1} 
      return i; 
    } 
  } 
  return -1; 
}

[]O(N2)
For the O(n2) example, let's use the bubble sort algorithm:

function swap(array, index1, index2){ 
  var aux = array[index1]; 
  array[index1] = array[index2]; 
  array[index2] = aux; 
} 
 
function bubbleSort(array){ 
  var length = array.length; 
  for (var i=0; i&lt;length; i++){    //{1} 
    for (var j=0; j&lt;length-1; j++ ){ //{2} 
      if (array[j] &gt; array[j+1]){ 
        swap(array, j, j+1); 
      } 
    } 
  } 
}

*/</span>

<span class="hljs-comment">// O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> ++num;
}
<span class="hljs-built_in">console</span>.log(increment(<span class="hljs-number">2</span>));


<span class="hljs-comment">// O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sequentialSearch</span>(<span class="hljs-params">array, item</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
        <span class="hljs-keyword">if</span> (item === array[i]) { <span class="hljs-comment">//{1} </span>
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-keyword">let</span> input1 = [<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>];

<span class="hljs-built_in">console</span>.log(sequentialSearch(input1, <span class="hljs-number">4</span>));



<span class="hljs-comment">// O(n^2)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">array, index1, index2</span>) </span>{
    <span class="hljs-keyword">let</span> aux = array[index1];
    array[index1] = array[index2];
    array[index2] = aux;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">let</span> length = array.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) { <span class="hljs-comment">//{1} </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) { <span class="hljs-comment">//{2} </span>
            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
                swap(array, j, j + <span class="hljs-number">1</span>);
            }
        }
    }
    <span class="hljs-keyword">return</span> array;
}
<span class="hljs-built_in">console</span>.log(bubbleSort(input1));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/big-o.svg" alt="./examples/big-o.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="7---examplesbinary-searchjs">7 - ./examples/binary-search.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>(<span class="hljs-params">arr, val</span>) </span>{
    <span class="hljs-keyword">let</span> lower_bound = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> upper_bound = arr.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (lower_bound &lt;= upper_bound) {
        <span class="hljs-keyword">let</span> midpoint = <span class="hljs-built_in">Math</span>.floor(upper_bound + lower_bound / <span class="hljs-number">2</span>);
        <span class="hljs-keyword">let</span> value_at_midpoint = arr[midpoint];

        <span class="hljs-built_in">console</span>.log(midpoint, value_at_midpoint);

        <span class="hljs-keyword">if</span> (val &lt; value_at_midpoint) {
            upper_bound = midpoint - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; value_at_midpoint) {
            lower_bound = midpoint + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == value_at_midpoint) {
            <span class="hljs-keyword">return</span> midpoint;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">//console.log(binarySearch([1, 3, 4, 5, 6, 21, 43, 54, 86], 21));</span>
<span class="hljs-comment">//console.log(binarySearch([1, 3, 4, 5, 6, 21, 43, 54, 86], 1));</span>

<span class="hljs-comment">/**
 * 
 * Given two unsorted arrays of distinct elements, 
 * the task is to find all pairs from both arrays whose sum is equal to x.
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPairs</span>(<span class="hljs-params">arr1, arr2, x</span>) </span>{
    <span class="hljs-keyword">let</span> map = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) {
        map[arr1[i]] = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr2.length; j++) {
        <span class="hljs-built_in">console</span>.log(x - arr2[j]);
        <span class="hljs-keyword">if</span> (map[x - arr2[j]]) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Found pair'</span>);
        }
    }

}
<span class="hljs-built_in">console</span>.log(findPairs([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], <span class="hljs-number">8</span>))
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/binary-search.svg" alt="./examples/binary-search.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="8---examplesbubble-sortjs">8 - ./examples/bubble-sort.js</h2>
<pre class="hljs"><code><div>    
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">array, index1, index2</span>) </span>{
    <span class="hljs-keyword">var</span> aux = array[index1];
    array[index1] = array[index2];
    array[index2] = aux;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">let</span> length = array.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        <span class="hljs-built_in">console</span>.log(i, array)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
                swap(array, j, j + <span class="hljs-number">1</span>);
            }
        }
    }
    <span class="hljs-keyword">return</span> array;
}
<span class="hljs-built_in">console</span>.log(bubbleSort([<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/bubble-sort.svg" alt="./examples/bubble-sort.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="9---examplesclimb-stairsjs">9 - ./examples/climb-stairs.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

</span></div></code></pre>
<p>Input: 2
Output: 2
Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps</li>
</ol>
<pre class="hljs"><code><div>
Example 2:

</div></code></pre>
<p>Input: 3
Output: 3
Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<pre class="hljs"><code><div>*/
var fib = function (n) {
    let fibo = [0, 1];
    if (n &lt;= 2) return 1;
    for (var i = 2; i &lt;= n; i++) {
        fibo[i] = fibo[i - 1] + fibo[i - 2];
    }
    return fibo[n];
}
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    return fib(n + 1)
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/climb-stairs.svg" alt="./examples/climb-stairs.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="10---examplescoin-changejs">10 - ./examples/coin-change.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> print = <span class="hljs-built_in">console</span>.log.apply;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeChange</span>(<span class="hljs-params">origAmt, coins</span>) </span>{
    <span class="hljs-keyword">var</span> remainAmt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (origAmt % <span class="hljs-number">.25</span> &lt; origAmt) {
       coins[<span class="hljs-number">3</span>] = <span class="hljs-built_in">parseInt</span>(origAmt / <span class="hljs-number">.25</span>);
       remainAmt = origAmt % <span class="hljs-number">.25</span>;
       origAmt = remainAmt;
    }
    <span class="hljs-keyword">if</span> (origAmt % <span class="hljs-number">.1</span> &lt; origAmt) {
       coins[<span class="hljs-number">2</span>] = <span class="hljs-built_in">parseInt</span>(origAmt / <span class="hljs-number">.1</span>);
       remainAmt = origAmt % <span class="hljs-number">.1</span>;
       origAmt = remainAmt;
    }
    <span class="hljs-keyword">if</span> (origAmt % <span class="hljs-number">.05</span> &lt; origAmt) {
       coins[<span class="hljs-number">1</span>] = <span class="hljs-built_in">parseInt</span>(origAmt / <span class="hljs-number">.05</span>);
       remainAmt = origAmt % <span class="hljs-number">.05</span>;
       origAmt = remainAmt;
    }
    coins[<span class="hljs-number">0</span>] = <span class="hljs-built_in">parseInt</span>(origAmt / <span class="hljs-number">.01</span>);
 }
 
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showChange</span>(<span class="hljs-params">coins</span>) </span>{
    <span class="hljs-keyword">if</span> (coins[<span class="hljs-number">3</span>] &gt; <span class="hljs-number">0</span>) {
       print(<span class="hljs-string">"Number of quarters - "</span> + coins[<span class="hljs-number">3</span>] + <span class="hljs-string">" - "</span> + coins[<span class="hljs-number">3</span>] * <span class="hljs-number">.25</span>);
    }
    <span class="hljs-keyword">if</span> (coins[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) {
       print(<span class="hljs-string">"Number of dimes - "</span> + coins[<span class="hljs-number">2</span>] + <span class="hljs-string">" - "</span> + coins[<span class="hljs-number">2</span>] * <span class="hljs-number">.10</span>);
    }
    <span class="hljs-keyword">if</span> (coins[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) {
       print(<span class="hljs-string">"Number of nickels - "</span> + coins[<span class="hljs-number">1</span>] + <span class="hljs-string">" - "</span> + coins[<span class="hljs-number">1</span>] * <span class="hljs-number">.05</span>);
    }
    <span class="hljs-keyword">if</span> (coins[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) {
       print(<span class="hljs-string">"Number of pennies - "</span> + coins[<span class="hljs-number">0</span>] + <span class="hljs-string">" - "</span> + coins[<span class="hljs-number">0</span>] * <span class="hljs-number">.01</span>);
    }
 }
 
 <span class="hljs-keyword">var</span> origAmt = <span class="hljs-number">.63</span>;
 <span class="hljs-keyword">var</span> coins = [];
 makeChange(origAmt, coins);
 showChange(coins);
 
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/coin-change.svg" alt="./examples/coin-change.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="11---examplescontains-duplicatejs">11 - ./examples/contains-duplicate.js</h2>
<pre class="hljs"><code><div>    
<span class="hljs-comment">/**
 * Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

Example 1:

Input: [1,2,3,1]
Output: true
Example 2:

Input: [1,2,3,4]
Output: false
Example 3:

Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
 * @param {number[]} nums
 * @return {boolean}
 */</span>
<span class="hljs-keyword">var</span> containsDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> result = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> len = nums.length;
    <span class="hljs-keyword">let</span> matchCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (p1 &lt; len) {
        <span class="hljs-keyword">let</span> n1 = nums[p1];
        p2 = p1 + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p2 &lt; len) {
            <span class="hljs-keyword">let</span> n2 = nums[p2];
            p2++;
            <span class="hljs-keyword">if</span> (n1 == n2) {
                result = <span class="hljs-literal">true</span>;
            }
        }
        p1++;
    }

    <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">var</span> containsDuplicate2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">var</span> counter = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (counter.hasOwnProperty(nums[i])) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
            counter[nums[i]] = <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-built_in">console</span>.time(<span class="hljs-string">'containsDuplicate'</span>);
<span class="hljs-built_in">console</span>.log(containsDuplicate([<span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>]));
<span class="hljs-built_in">console</span>.log(containsDuplicate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'containsDuplicate'</span>);


<span class="hljs-built_in">console</span>.time(<span class="hljs-string">'containsDuplicate2'</span>);
<span class="hljs-built_in">console</span>.log(containsDuplicate2([<span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>]));
<span class="hljs-built_in">console</span>.log(containsDuplicate2([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'containsDuplicate2'</span>);
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/contains-duplicate.svg" alt="./examples/contains-duplicate.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="12---examplescount-and-sayjs">12 - ./examples/count-and-say.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// The count-and-say sequence is the sequence of integers with the first five terms as following:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1.     1</span>
<span class="hljs-comment">// 2.     11</span>
<span class="hljs-comment">// 3.     21</span>
<span class="hljs-comment">// 4.     1211</span>
<span class="hljs-comment">// 5.     111221</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1 is read off as "one 1" or 11.</span>
<span class="hljs-comment">// 11 is read off as "two 1s" or 21.</span>
<span class="hljs-comment">// 21 is read off as "one 2, then one 1" or 1211.</span>
<span class="hljs-comment">// Given an integer n, generate the nth term of the count-and-say sequence.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Note: Each term of the sequence of integers will be represented as a string.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: 1</span>
<span class="hljs-comment">// Output: "1"</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: 4</span>
<span class="hljs-comment">// Output: "1211"</span>

<span class="hljs-comment">/**
 * @param {number} n
 * @return {string}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countAndSay</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">let</span> res = <span class="hljs-string">'1'</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        res = say(res);
    }

    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> res = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> num = str[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) {
        <span class="hljs-keyword">if</span> (str[i] === num) {
            count++;
        } <span class="hljs-keyword">else</span> {
            res += count + str[i - <span class="hljs-number">1</span>];
            count = <span class="hljs-number">1</span>;
            num = str[i];
        }
    }

    <span class="hljs-keyword">return</span> res + count + num;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/count-and-say.svg" alt="./examples/count-and-say.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="13---examplesdelete-nth-linked-listjs">13 - ./examples/delete-nth-linked-list.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Delete Node in a Linked List

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:
</span></div></code></pre>
<pre><code>4 -&gt; 5 -&gt; 1 -&gt; 9
</code></pre>
<pre class="hljs"><code><div>*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * // Since we do not have access to the node before the one we want to delete, we cannot modify the next pointer of that node in any way.
// Instead, we have to replace the value of the node we want to delete with the value in the node after it, and then delete the node after it.
// Because we know that the node we want to delete is not the tail of the list, we can guarantee that this approach is possible.

 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function (node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/delete-nth-linked-list.svg" alt="./examples/delete-nth-linked-list.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="14---examplesdiagonal-traversejs">14 - ./examples/diagonal-traverse.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * Diagonal Traverse
 * Given a matrix of M x N elements (M rows, N columns),
 * return all elements of the matrix in diagonal order as shown in the below image.
 *
 * @param {number[][]} matrix
 * @return {number[]}
 */</span>
<span class="hljs-keyword">var</span> findDiagonalOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>{
    <span class="hljs-keyword">if</span> (matrix.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">let</span> len = matrix.length;
    <span class="hljs-keyword">let</span> len2 = matrix[<span class="hljs-number">0</span>].length;
    <span class="hljs-keyword">let</span> len3 = len * len2;
    <span class="hljs-keyword">let</span> res = [];
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,
        j = <span class="hljs-number">0</span>,
        k = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (k &lt; len3) {
        res.push(matrix[i][j]);
        <span class="hljs-keyword">if</span> ((i + j) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (i === len - <span class="hljs-number">1</span>) {
                j++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>) {
                i++;
            } <span class="hljs-keyword">else</span> {
                i++;
                j--;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (j === len2 - <span class="hljs-number">1</span>) {
                i++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
                j++;
            } <span class="hljs-keyword">else</span> {
                i--;
                j++;
            }
        }
        k++;
    }
    <span class="hljs-keyword">return</span> res;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/diagonal-traverse.svg" alt="./examples/diagonal-traverse.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="15---examplesexamplejs">15 - ./examples/example.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexSearch</span>(<span class="hljs-params">list, element</span>) </span>{
    <span class="hljs-keyword">let</span> currentIndex,
        currentElement,
        minIndex = <span class="hljs-number">0</span>,
        maxIndex = list.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (minIndex &lt;= maxIndex) {
        currentIndex = <span class="hljs-built_in">Math</span>.floor(maxIndex + maxIndex) / <span class="hljs-number">2</span>;
        currentElement = list[currentIndex];

        <span class="hljs-keyword">if</span> (currentElement === element) {
            <span class="hljs-keyword">return</span> currentIndex;
        }

        <span class="hljs-keyword">if</span> (currentElement &lt; element) {
            minIndex = currentIndex + <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">if</span> (currentElement &gt; element) {
            maxIndex = currentIndex - <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/example.svg" alt="./examples/example.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="16---examplesfibjs">16 - ./examples/fib.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>)</span>{
    <span class="hljs-keyword">if</span>(n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>); 
}

<span class="hljs-built_in">console</span>.log(fib(<span class="hljs-number">5</span>));

</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/fib.svg" alt="./examples/fib.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="17---examplesfirst-bad-versionjs">17 - ./examples/first-bad-version.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Given n = 5</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// call isBadVersion(3) -&gt; false</span>
<span class="hljs-comment">// call isBadVersion(5) -&gt; true</span>
<span class="hljs-comment">// call isBadVersion(4) -&gt; true</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Then 4 is the first bad version.</span>

<span class="hljs-comment">/**
 * Definition for isBadVersion()
 *
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */</span>

<span class="hljs-comment">/**
 * @param {function} isBadVersion()
 * @return {function}
 */</span>

<span class="hljs-comment">/** Binary search */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solution</span>(<span class="hljs-params">isBadVersion</span>) </span>{
  <span class="hljs-comment">/**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">return</span> find(<span class="hljs-number">1</span>, n);
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">l, r</span>) </span>{
    <span class="hljs-keyword">if</span> (l === r) <span class="hljs-keyword">return</span> l;

    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((l + r) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> isBadVersion(mid) ? find(l, mid) : find(mid + <span class="hljs-number">1</span>, r);
  }
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/first-bad-version.svg" alt="./examples/first-bad-version.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="18---examplesfirst-uniq-charjs">18 - ./examples/first-uniq-char.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## First Unique Character in a String
Given a string, find the first non-repeating character in it and return it's index. 
If it doesn't exist, return -1.

Examples:

s = "leetcode"
return 0.

s = "loveleetcode",
return 2.

&gt; Note: You may assume the string contain only lowercase letters.
*/</span>
<span class="hljs-comment">/**
 * @param {string} s
 * @return {number}
 */</span>
<span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">var</span> map = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
        <span class="hljs-keyword">let</span> key = s[i];
        <span class="hljs-keyword">if</span> (map[key] === <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// if letter hasn't been encountered </span>
            <span class="hljs-comment">// set char as key and value ([index, count]) as tuple of the index and letter count</span>
            map[key] = [i, <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// increment letter count</span>
            map[key][<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;
            <span class="hljs-built_in">console</span>.log(key, i)
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> map) {
        <span class="hljs-built_in">console</span>.log(k, map[k]);
        <span class="hljs-comment">// if a character count is equal to 1 it is the first unique, so return</span>
        <span class="hljs-keyword">if</span> (map[k][<span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> map[k][<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// return -1 if we didnt find a unique in our map</span>
};
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'abc'</span>));
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'aba'</span>));
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'loveleetcode'</span>));

</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/first-uniq-char.svg" alt="./examples/first-uniq-char.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="19---examplesfizz-buzzjs">19 - ./examples/fizz-buzz.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Fizz Buzz
Write a program that outputs the string representation of numbers from 1 to n.

But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.

Example:
</span></div></code></pre>
<p>n = 15,</p>
<p>Return:
[
&quot;1&quot;,
&quot;2&quot;,
&quot;Fizz&quot;, 3
&quot;4&quot;,
&quot;Buzz&quot;,
&quot;Fizz&quot;, 6
&quot;7&quot;,
&quot;8&quot;,
&quot;Fizz&quot;, 9
&quot;Buzz&quot;,
&quot;11&quot;,
&quot;Fizz&quot;, 12
&quot;13&quot;,
&quot;14&quot;,
&quot;FizzBuzz&quot;
]</p>
<pre class="hljs"><code><div>*/
/**
 * @param {number} n
 * @return {string[]}
 */
function fizzBuzz(n) {
    let arr = [];

    for (let i = 1; i &lt;= n; i++) {
        if (i % 15 === 0) arr.push('FizzBuzz');
        else if (i % 3 === 0) arr.push('Fizz');
        else if (i % 5 === 0) arr.push('Buzz');
        else arr.push(String(i));
    }

    return arr;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/fizz-buzz.svg" alt="./examples/fizz-buzz.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="20---examplesgroup-anagramsjs">20 - ./examples/group-anagrams.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {string[]} strs
 * @return {string[][]}
 */</span>


<span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>{

    <span class="hljs-comment">// 1 sort each word's letters to enable matching</span>
    <span class="hljs-comment">// alph will be, e.g.: ['aet', 'aet', 'ant' ...]</span>
    <span class="hljs-keyword">var</span> alph = strs.map(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.split(<span class="hljs-string">''</span>).sort().join(<span class="hljs-string">''</span>));

    <span class="hljs-comment">// 2 create groups of indices of identical sorted words</span>
    <span class="hljs-comment">// locations will be, e.g.: { 'aet': [0, 1, 3], 'ant': [...] }</span>
    <span class="hljs-keyword">var</span> locations = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; alph.length; i++) {
        <span class="hljs-keyword">if</span> (!locations[alph[i]]) {
            locations[alph[i]] = [i];
        } <span class="hljs-keyword">else</span> {
            locations[alph[i]].push(i);
        }
    }
    <span class="hljs-built_in">console</span>.log(locations);

    <span class="hljs-comment">// 3 transform groups of indices into groups of original words</span>
    <span class="hljs-comment">// e.g. for 'aet', map [0, 1, 3] to words at those indices in strs</span>
    <span class="hljs-keyword">var</span> output = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> word <span class="hljs-keyword">in</span> locations) {
        output.push(locations[word].map(<span class="hljs-function"><span class="hljs-params">idx</span> =&gt;</span> strs[idx]));
    }
    <span class="hljs-keyword">return</span> output;
};
<span class="hljs-built_in">console</span>.log(
    groupAnagrams([<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>])
)
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/group-anagrams.svg" alt="./examples/group-anagrams.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="21---exampleshas-path-sumjs">21 - ./examples/has-path-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) </span>{
    <span class="hljs-keyword">let</span> node = root;
    <span class="hljs-keyword">if</span>(!node){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">if</span>(node === <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> (sum === <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">let</span> answer = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> subsum = sum - node.val;
    <span class="hljs-keyword">if</span>(subsum === <span class="hljs-number">0</span> &amp;&amp; node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } 
    <span class="hljs-keyword">if</span>(node.left !== <span class="hljs-literal">null</span>){
       answer = answer || hasPathSum(node.left, subsum);
    }
    <span class="hljs-keyword">if</span>(node.right !== <span class="hljs-literal">null</span>){
       answer = answer || hasPathSum(node.right, subsum);
    }
    <span class="hljs-keyword">return</span> answer;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/has-path-sum.svg" alt="./examples/has-path-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="22---exampleshour-glassjs">22 - ./examples/hour-glass.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> input = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]
];

<span class="hljs-keyword">let</span> input2 = [
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hourglassSum</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> maxSum = <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
        <span class="hljs-keyword">const</span> row = arr[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) {
            <span class="hljs-keyword">const</span> col = row[j];
            sum = (
                arr[i][j] +
                arr[i][j + <span class="hljs-number">1</span>] +
                arr[i][j + <span class="hljs-number">2</span>] +
                arr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] +
                arr[i + <span class="hljs-number">2</span>][j] +
                arr[i + <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] +
                arr[i + <span class="hljs-number">2</span>][j + <span class="hljs-number">2</span>]
            );
            <span class="hljs-keyword">if</span> (sum &gt; maxSum) {
                maxSum = sum;
            }
        }

    }
    <span class="hljs-keyword">return</span> maxSum
}

<span class="hljs-built_in">console</span>.log(hourglassSum(input));
<span class="hljs-built_in">console</span>.log(hourglassSum(input2));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/hour-glass.svg" alt="./examples/hour-glass.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="23---exampleshouse-robberjs">23 - ./examples/house-robber.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [1,2,3,1]</span>
<span class="hljs-comment">// Output: 4</span>
<span class="hljs-comment">// Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span>
<span class="hljs-comment">//   Total amount you can rob = 1 + 3 = 4.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: [2,7,9,3,1]</span>
<span class="hljs-comment">// Output: 12</span>
<span class="hljs-comment">// Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span>
<span class="hljs-comment">//   Total amount you can rob = 2 + 9 + 1 = 12.</span>

<span class="hljs-comment">/**
 * @param {number[]} nums
 * @return {number}
 */</span>

<span class="hljs-comment">/** 1) Recursion */</span>
<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rob1</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> count(nums.length - <span class="hljs-number">1</span>, [], nums)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params">n, cache, nums</span>) </span>{
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (cache[n] !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> cache[n];

    cache[n] = <span class="hljs-built_in">Math</span>.max(
        count(n - <span class="hljs-number">2</span>, cache, nums) + nums[n],
        count(n - <span class="hljs-number">1</span>, cache, nums)
    );

    <span class="hljs-keyword">return</span> cache[n];
}

<span class="hljs-comment">/** 2) Iteration */</span>
<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rob2</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">const</span> totals = [nums[<span class="hljs-number">0</span>], <span class="hljs-built_in">Math</span>.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; nums.length; i++) {
        totals.push(<span class="hljs-built_in">Math</span>.max(totals[i - <span class="hljs-number">2</span>] + nums[i], totals[i - <span class="hljs-number">1</span>]));
    }

    <span class="hljs-keyword">return</span> totals[totals.length - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">/** 3) Iteration */</span>
<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rob3</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">let</span> a = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Math</span>.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max(a + nums[i], b);
        a = b;
        b = max;
    }

    <span class="hljs-keyword">return</span> b;
}

<span class="hljs-comment">/** 4) Iteration */</span>
<span class="hljs-comment">// time O(n)</span>
<span class="hljs-comment">// space O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rob</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) a = <span class="hljs-built_in">Math</span>.max(a + nums[i], b);
        <span class="hljs-keyword">else</span> b = <span class="hljs-built_in">Math</span>.max(a, b + nums[i]);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(a, b);
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/house-robber.svg" alt="./examples/house-robber.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="24---examplesis-palindromejs">24 - ./examples/is-palindrome.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">word</span>) </span>{
    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Stack();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; word.length; ++i) {
       s.push(word[i]);
    }
    <span class="hljs-keyword">var</span> rword = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">while</span> (s.length() &gt; <span class="hljs-number">0</span>) {
       rword += s.pop();
    }
    <span class="hljs-keyword">if</span> (word == rword) {
       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
     }
    <span class="hljs-keyword">else</span> {
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
 }
 
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/is-palindrome.svg" alt="./examples/is-palindrome.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="25---examplesis-valid-paramsjs">25 - ./examples/is-valid-params.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> c;
    <span class="hljs-keyword">let</span> dict = {
      <span class="hljs-string">'{'</span>: <span class="hljs-string">'}'</span>,
      <span class="hljs-string">'('</span>: <span class="hljs-string">')'</span>,
      <span class="hljs-string">'['</span>: <span class="hljs-string">']'</span>
    };
    <span class="hljs-keyword">let</span> stack = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
      c = s[i];
      <span class="hljs-keyword">if</span> (dict[c]) {
        stack.push(c);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (dict[stack.pop()] !== c) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> (stack.length === <span class="hljs-number">0</span>);
  };
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/is-valid-params.svg" alt="./examples/is-valid-params.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="26---examplesknapsackjs">26 - ./examples/knapsack.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;
 }
 
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">knapsack</span>(<span class="hljs-params">capacity, size, value, n</span>) </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || capacity == <span class="hljs-number">0</span>) {
       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (size[n<span class="hljs-number">-1</span>] &gt; capacity) {
       <span class="hljs-keyword">return</span> knapsack(capacity, size, value, n<span class="hljs-number">-1</span>);
    }
    <span class="hljs-keyword">else</span> {
       <span class="hljs-keyword">return</span> max(value[n<span class="hljs-number">-1</span>] +
                  knapsack(capacity-size[n<span class="hljs-number">-1</span>], size, value, n<span class="hljs-number">-1</span>),
                  knapsack(capacity, size, value, n<span class="hljs-number">-1</span>));
    }
 }
 
 <span class="hljs-keyword">var</span> value = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>];
 <span class="hljs-keyword">var</span> size = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];
 <span class="hljs-keyword">var</span> capacity = <span class="hljs-number">16</span>;
 <span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span>;
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/knapsack.svg" alt="./examples/knapsack.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="27---exampleskth-largest-elementjs">27 - ./examples/kth-largest-element.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Kth Largest Element in an Array

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

</span></div></code></pre>
<p>Input: [3,2,1,5,6,4] and k = 2
Output: 5</p>
<pre class="hljs"><code><div>
Example 2:

</div></code></pre>
<p>Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4</p>
<pre class="hljs"><code><div>
Note: 
- You may assume k is always valid, 1 ≤ k ≤ array's length.

*/
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function (nums, k) {
    var sorted = nums.sort(function (a, b) {
        return a - b;
    });
    var array = [];

    for (var i = sorted.length - 1; i &gt;= sorted.length - k; i--) {
        array.push(sorted[i]);
    }

    return array.pop();
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/kth-largest-element.svg" alt="./examples/kth-largest-element.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="28---exampleslength-of-longest-substringjs">28 - ./examples/length-of-longest-substring.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * 
 * Using a map to keep track of the count of each appeared characters.
Once the count of character at right is greater than 1, 
we will try to move left pointer to approach to right until the count of that character is less or equal to 1.
We update the max length of non-repeating substring during looping.
 * 
 * 
 */</span>
<span class="hljs-keyword">const</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">if</span> (str.length === <span class="hljs-number">0</span> || str === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">const</span> map = {};
    <span class="hljs-keyword">let</span> len = str.length
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; right &lt; len; right++) {
        <span class="hljs-keyword">let</span> ch = str.charAt(right)
        map[ch] ? map[ch]++ : map[ch] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> (map[ch] &gt; <span class="hljs-number">1</span> &amp;&amp; left &lt; right) {
            map[str.charAt(left)]--
                left++
        }
        <span class="hljs-built_in">console</span>.log(map)
        max = <span class="hljs-built_in">Math</span>.max(max, right - left + <span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">return</span> max
}

<span class="hljs-built_in">console</span>.log(lengthOfLongestSubstring(<span class="hljs-string">"pwwkew"</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/length-of-longest-substring.svg" alt="./examples/length-of-longest-substring.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="29---examplesletter-combinationsjs">29 - ./examples/letter-combinations.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> mappings = {
    <span class="hljs-number">1</span>: <span class="hljs-string">""</span>,
    <span class="hljs-number">2</span>: <span class="hljs-string">"abc"</span>,
    <span class="hljs-number">3</span>: <span class="hljs-string">"def"</span>,
    <span class="hljs-number">4</span>: <span class="hljs-string">"ghi"</span>,
    <span class="hljs-number">5</span>: <span class="hljs-string">"jkl"</span>,
    <span class="hljs-number">6</span>: <span class="hljs-string">"mno"</span>,
    <span class="hljs-number">7</span>: <span class="hljs-string">"pqrs"</span>,
    <span class="hljs-number">8</span>: <span class="hljs-string">"tuv"</span>,
    <span class="hljs-number">9</span>: <span class="hljs-string">"wxyz"</span>
};

<span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">digits</span>) </span>{
    <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits === <span class="hljs-string">""</span>) {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">let</span> res = []; <span class="hljs-comment">// initialize the result array</span>
    <span class="hljs-keyword">let</span> currIdx = <span class="hljs-number">0</span>; <span class="hljs-comment">// keep track of the current index of digit we are looking at</span>
    <span class="hljs-keyword">let</span> currStr = <span class="hljs-string">""</span>; <span class="hljs-comment">// keep track of the current substring we are exploring</span>
    backtracking(res, digits, currIdx, currStr); <span class="hljs-comment">// start recursion</span>
    <span class="hljs-keyword">return</span> res;
};

<span class="hljs-keyword">var</span> backtracking = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res, digits, currIdx, currStr</span>) </span>{
    <span class="hljs-keyword">if</span> (currIdx === digits.length) {
        <span class="hljs-keyword">return</span> res.push(currStr); <span class="hljs-comment">// one of the solution now is complete, push it to the array</span>
    }

    <span class="hljs-keyword">const</span> c = digits[currIdx]; <span class="hljs-comment">// get the current character    </span>
    <span class="hljs-keyword">const</span> mapping = mappings[c]; <span class="hljs-comment">// get its mapping</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> s <span class="hljs-keyword">of</span> mapping) { <span class="hljs-comment">// iterate through every character in the mapping</span>
        currStr += s;
        backtracking(res, digits, currIdx + <span class="hljs-number">1</span>, currStr); <span class="hljs-comment">// recursion</span>
        currStr = currStr.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// revert currStr back</span>
    }
};

<span class="hljs-comment">//["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</span>
<span class="hljs-built_in">console</span>.log(letterCombinations(<span class="hljs-string">'23'</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/letter-combinations.svg" alt="./examples/letter-combinations.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="30---exampleslevel-orderjs">30 - ./examples/level-order.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> [];
    }
    <span class="hljs-keyword">let</span> result = [];
    <span class="hljs-keyword">let</span> queue = [];

    queue.push(root);

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">let</span> size = queue.length;
        <span class="hljs-keyword">let</span> current = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
            <span class="hljs-keyword">let</span> head = queue.shift();
            current.push(head.val);
            <span class="hljs-keyword">if</span> (head.left !== <span class="hljs-literal">null</span>) {
                queue.push(head.left)
            }
            <span class="hljs-keyword">if</span> (head.right !== <span class="hljs-literal">null</span>) {
                queue.push(head.right)
            }
        }
        result.push(current);
    }
    <span class="hljs-keyword">return</span> result;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/level-order.svg" alt="./examples/level-order.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="31---exampleslongest-common-prefixjs">31 - ./examples/longest-common-prefix.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {string[]} strs
 * @return {string}
 */</span>
<span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) </span>{
    <span class="hljs-keyword">if</span> (strs &amp;&amp; strs.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }
    strs.sort(<span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> prev.length - next.length)
    shortestStr = strs[<span class="hljs-number">0</span>]
    length = shortestStr &amp;&amp; shortestStr.length
    <span class="hljs-keyword">if</span> (!length) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = length; i &gt; <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">const</span> searchStr = shortestStr.substr(<span class="hljs-number">0</span>, i);
        flag = strs.every(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item &amp;&amp; item.startsWith &amp;&amp; item.startsWith(searchStr))
        <span class="hljs-keyword">if</span> (flag) {
            <span class="hljs-keyword">return</span> searchStr
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/longest-common-prefix.svg" alt="./examples/longest-common-prefix.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="32---exampleslongest-palindromic-substringjs">32 - ./examples/longest-palindromic-substring.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Longest Palindromic Substring
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

</span></div></code></pre>
<p>Input: &quot;babad&quot;
Output: &quot;bab&quot;</p>
<pre class="hljs"><code><div>Note: &quot;aba&quot; is also a valid answer.


Example 2:

</div></code></pre>
<p>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;</p>
<pre class="hljs"><code><div> */
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    console.log(s);
};

function isPalindrome(word) {
    return word === word.split('').reverse().join('');
}




let isEven = (n) =&gt; n % 2 !== 1;
let isOdd = (n) =&gt; n % 2 === 1;



//[2,4,6,8,10].map( val =&gt; console.log(isEven(val)));
[1,3,5,7,9, 11, 13].map( val =&gt; console.log(isOdd(val)))






console.log(longestPalindrome('babad'));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/longest-palindromic-substring.svg" alt="./examples/longest-palindromic-substring.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="33---examplesmax-depth-of-binary-treejs">33 - ./examples/max-depth-of-binary-tree.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

&gt; Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

</span></div></code></pre>
<pre><code>3
</code></pre>
<p>/ <br>
9  20
/  <br>
15   7</p>
<pre class="hljs"><code><div>
return its depth = 3.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root === null) {
        return 0;
    }
    let left_depth = maxDepth(root.left);
    let right_depth = maxDepth(root.right);
    return Math.max(left_depth, right_depth) + 1;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/max-depth-of-binary-tree.svg" alt="./examples/max-depth-of-binary-tree.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="34---examplesmax-sub-array-lenjs">34 - ./examples/max-sub-array-len.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> maxSubArrayLen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>{
    <span class="hljs-keyword">let</span> subarrayLength = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> map = {
        <span class="hljs-number">0</span>: <span class="hljs-number">-1</span>
    };
    nums.forEach(<span class="hljs-function">(<span class="hljs-params">number, i</span>) =&gt;</span> {
        sum += number;
        <span class="hljs-keyword">if</span> (!map.hasOwnProperty(sum)) {
            map[sum] = i;
        }
        <span class="hljs-keyword">if</span> (map.hasOwnProperty(sum - k)) {
            subarrayLength = <span class="hljs-built_in">Math</span>.max(subarrayLength, i - map[sum - k]);
        }
    });
    <span class="hljs-keyword">return</span> subarrayLength;
};

<span class="hljs-built_in">console</span>.log(maxSubArrayLen([<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">3</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/max-sub-array-len.svg" alt="./examples/max-sub-array-len.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="35---examplesmax-sub-arrayjs">35 - ./examples/max-sub-array.js</h2>
<pre class="hljs"><code><div>    
<span class="hljs-comment">/*
Basic idea is to keep track of the largest sum at current index and to 
achieve that we can compare the number on current index and the sum of the 
number on current index plus previous sum (previous sum set to -Infinity).
If the result is greater than the number on current index that means it has the 
potential to be included in the contiguous subarray so we add to previous sum.
 
But if the result is less than the number on current index that means we can simply 
ignore the result and set the previous sum to be the current number.

And as we compute previous sum, we can also compute max by find out what the maximum previous sum is. (we set max to nums[0] in case nums has only 1 element)
*/</span>
<span class="hljs-keyword">var</span> maxSubArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> currentMax = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> previousSum = -<span class="hljs-literal">Infinity</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
        <span class="hljs-comment">//console.log(previousSum);</span>
        previousSum = <span class="hljs-built_in">Math</span>.max(num, num + previousSum);
        currentMax = <span class="hljs-built_in">Math</span>.max(previousSum, currentMax);
    }
    
    <span class="hljs-keyword">return</span> currentMax;
};
<span class="hljs-built_in">console</span>.log(maxSubArray([<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/max-sub-array.svg" alt="./examples/max-sub-array.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="36---examplesmaximum-sub-arrayjs">36 - ./examples/maximum-sub-array.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
# Maximum Subarray

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

</span></div></code></pre>
<p>Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.</p>
<pre class="hljs"><code><div>
Follow up:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
 
### Kadane’s Algorithm:

</div></code></pre>
<p>Initialize:
max_so_far = 0
max_ending_here = 0</p>
<p>Loop for each element of the array
(a) max_ending_here = max_ending_here + a[i]
(b) if(max_ending_here &lt; 0)
max_ending_here = 0
(c) if(max_so_far &lt; max_ending_here)
max_so_far = max_ending_here
return max_so_far</p>
<pre class="hljs"><code><div>
*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let max_so_far = Number.MIN_SAFE_INTEGER;
    let max_ending_here = 0;
    let size = nums.length;
    if(size === 1){
        return nums[0]
    }
    for (let index = 0; index &lt; size; index++) {
        const num = nums[index];
        max_ending_here = max_ending_here + num;
        if(max_ending_here &lt; num){
            max_ending_here = num;
        }
        if(max_so_far &lt; max_ending_here){
            max_so_far = max_ending_here;
        }
        console.log(max_so_far);
    }
    return max_so_far;
};

var maxSubArray2 = function(nums) {
    for (let i = 1; i &lt; nums.length; i++){
        nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);
    }
    return Math.max(...nums);
};
let input = [-2, 1, -3, 4, -1, 2, 1, -5, 4];


console.log(maxSubArray(input));
console.log(maxSubArray([-1]));
console.log(maxSubArray([-2, -1]));
console.assert(maxSubArray([-1]) === -1);

console.log(maxSubArray2(input));
console.log(maxSubArray2([-2, -1]));

</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/maximum-sub-array.svg" alt="./examples/maximum-sub-array.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="37---examplesmerge-arraysjs">37 - ./examples/merge-arrays.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">//imperative:</span>
<span class="hljs-keyword">const</span> mergeArrays_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arrays</span>) </span>{
    <span class="hljs-keyword">let</span> count = arrays.length;
    <span class="hljs-keyword">let</span> newArray = [];
    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arrays[i].length; j++) {
            newArray[k++] = arrays[i][j];
        }
    }
    <span class="hljs-keyword">return</span> newArray;
};
<span class="hljs-built_in">console</span>.log(mergeArrays_([
    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
    [<span class="hljs-number">6</span>]
]));

<span class="hljs-comment">// function-oriented</span>
<span class="hljs-keyword">const</span> mergeArrays = <span class="hljs-function">(<span class="hljs-params">...arrays</span>) =&gt;</span> [].concat(...arrays); 
<span class="hljs-built_in">console</span>.log(mergeArrays([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>])); 
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/merge-arrays.svg" alt="./examples/merge-arrays.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="38---examplesmerge-two-linked-listsjs">38 - ./examples/merge-two-linked-lists.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Merge Two Sorted Lists

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

</span></div></code></pre>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<pre class="hljs"><code><div>*/
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function (l1, l2) {

};

function mergeTwoLists(l1, l2) {
    // base case
    if (!l1 || !l2) return l1 || l2;

    
    if (l1.val &lt; l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/merge-two-linked-lists.svg" alt="./examples/merge-two-linked-lists.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="39---examplesmin-sub-array-lenjs">39 - ./examples/min-sub-array-len.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> minSubArrayLen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, nums</span>) </span>{
    <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">Infinity</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>; j &lt;= nums.length; ) {
        <span class="hljs-keyword">if</span> (sum &lt; s || i &gt;= j) {
            sum += nums[j++]
        } <span class="hljs-keyword">else</span> {
            ret = <span class="hljs-built_in">Math</span>.min(ret, j - i)
            sum -= nums[i++]
        }
    }
    <span class="hljs-keyword">return</span> ret === <span class="hljs-literal">Infinity</span> ? <span class="hljs-number">0</span> : ret
};
<span class="hljs-comment">//minSubArrayLen(7, [2,3,1,2,4,3]);</span>
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/min-sub-array-len.svg" alt="./examples/min-sub-array-len.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="40---examplesmin-swapsjs">40 - ./examples/min-swaps.js</h2>
<pre class="hljs"><code><div>    
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minSwaps2</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> answer = <span class="hljs-number">0</span>;
    arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
        answer++;
        <span class="hljs-keyword">return</span> a &gt; b;
    })
    <span class="hljs-built_in">console</span>.log(arr);
    <span class="hljs-keyword">return</span> answer % arr.length + <span class="hljs-number">1</span>;
}
<span class="hljs-built_in">console</span>.log(minSwaps2([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));



<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>{
    <span class="hljs-keyword">var</span> temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}


<span class="hljs-comment">/**
 * Create a pivot point and sort that way
 * @param {*} arr 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minSwaps3</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">let</span> answer = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    arr.map(<span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> map.set(val, index));

    <span class="hljs-comment">/*
    map[Symbol.iterator] = function* () {
        yield* [...this.entries()].sort((a, b) =&gt; a[1] - b[1]);
    }
    */</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) {
        <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">' '</span> + value);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; arr.length; index++) {
            <span class="hljs-keyword">if</span> (key !== arr[index]) {
                swap(arr, value, index);
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'swap'</span>, key, index);
            }
            <span class="hljs-built_in">console</span>.log(index);
        }

    }


    <span class="hljs-built_in">console</span>.log(arr, map);
    <span class="hljs-keyword">return</span> answer;
}

<span class="hljs-built_in">console</span>.log(minSwaps3([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));
<span class="hljs-comment">//console.log(minSwaps3([7, 1, 3, 2, 4, 5, 6]));</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap2</span>(<span class="hljs-params">arr, i</span>) </span>{
    <span class="hljs-keyword">let</span> temp = arr[arr[i] - <span class="hljs-number">1</span>];
    arr[arr[i] - <span class="hljs-number">1</span>] = arr[i];
    arr[i] = temp;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minimumSwaps</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-comment">//CHeck if next number is 1</span>
        <span class="hljs-built_in">console</span>.log(i, arr[i])
        <span class="hljs-keyword">if</span> (arr[i] !== i + <span class="hljs-number">1</span>) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Swap'</span>,i, i + <span class="hljs-number">1</span>);
            swap2(arr, i);
            count++;
        }
    }
    <span class="hljs-keyword">return</span> count;
}

<span class="hljs-built_in">console</span>.log(minimumSwaps([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/min-swaps.svg" alt="./examples/min-swaps.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="41---examplesmove-zerosjs">41 - ./examples/move-zeros.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Example:

Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.

 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */</span>
<span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> len = nums.length;
    <span class="hljs-keyword">let</span> numNonZero = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (left &lt; len) {
        <span class="hljs-keyword">if</span> (nums[left] != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> tmp = nums[numNonZero]
            nums[numNonZero] = nums[left]
            nums[left] = tmp;
            numNonZero += <span class="hljs-number">1</span>;
            left += <span class="hljs-number">1</span>
        } <span class="hljs-keyword">else</span> {
            left += <span class="hljs-number">1</span>
        }
    }
    <span class="hljs-keyword">return</span> nums;
};



<span class="hljs-keyword">var</span> moveZeroes2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> firstPos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (nums[i] !== <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> temp = nums[firstPos];
            nums[firstPos] = nums[i];
            nums[i] = temp;
            firstPos++;
        }
    }
    <span class="hljs-keyword">return</span> nums;
};

<span class="hljs-comment">//console.time('moveZeroes2');</span>
<span class="hljs-comment">//console.log(moveZeroes2([0, 1, 0, 3, 12]));</span>
<span class="hljs-comment">//console.log(moveZeroes2([0, 0, 3, 1]));</span>
<span class="hljs-comment">//console.log(moveZeroes2([]));</span>
<span class="hljs-comment">//console.timeEnd('moveZeroes2');</span>





<span class="hljs-comment">/*
## 3Sum

Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? 
Find all unique triplets in the array which gives the sum of zero.

&gt; Note: The solution set must not contain duplicate triplets.

Example:

Given array nums = `[-1, 0, 1, 2, -1, -4]`

A solution set is:
</span></div></code></pre>
<p>[
[-1, 0, 1],
[-1, -1, 2]
]</p>
<pre class="hljs"><code><div>*/

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
    nums.sort((a, b) =&gt; a - b);

    let results = [];
    let totalSum = 0;
    let i = 0
    while (i &lt; nums.length - 2) {
        let j = i + 1;
        let k = nums.length - 1;
        while (j &lt; k) {
            const sum = nums[i] + nums[j] + nums[k]
            if (sum &lt; totalSum) {

                while (nums[++j] === nums[j - 1]);
            } else if (sum &gt; totalSum) {
                while (nums[--k] === nums[k + 1]);
            } else {
                results.push([nums[i], nums[j], nums[k]])
                while (nums[++j] === nums[j - 1]);
                while (nums[--k] === nums[k + 1]);
            }
        }
        while (nums[++i] === nums[i - 1]);
    }
    return results;
};
//console.log(threeSum([-1, 0, 1, 2, -1, -4]));

/**
 * Validate if a given string is numeric.

Some examples:
&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
 * @param {string} s
 * @return {boolean}
 */
var isNumber = function (s) {

    return s.trim().length === 0 ? false : !isNaN(+s);
};

console.log(isNumber('1'));
console.log(isNumber('0'));
console.log(isNumber(' b '));
console.assert(isNumber(' 0.1 '));
console.assert(!isNumber(' b '));
console.assert(!isNumber('abc'));
console.assert(!isNumber('1 a'));
console.assert(isNumber('2e10'));





/**
 * 
 * Maximum Size Subarray Sum Equals k
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:

Input: nums = [1, -1, 5, -2, 3], k = 3
Output: 4 
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
Example 2:

Input: nums = [-2, -1, 2, 1], k = 1
Output: 2 
Explanation: The subarray [-1, 2] sums to 1 and is the longest.
Follow Up:
Can you do it in O(n) time?

The intuition is to create a map where u keep track of previous sums and their indecies. 
You keep adding to the sum until you get to a point 

- where the sum - k equals to one of the items already in the array. 
- this would mean that the sum of all the numbers after that sum - k number is k.

This would mean we have added up to the desired result, and we figure out how long that array is based on the indecies.
 */
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxSubArrayLen = function (nums, k) {
    let subarrayLength = 0;
    let sum = 0;
    let map = {
        0: -1
    };
    nums.forEach((number, i) =&gt; {
        sum += number;
        if (!map.hasOwnProperty(sum)) {
            map[sum] = i;
        }
        if (map.hasOwnProperty(sum - k)) {
            subarrayLength = Math.max(subarrayLength, i - map[sum - k]);
        }
    });
    return subarrayLength;
};

console.log(maxSubArrayLen([1, -1, 5, -2, 3], 3));




function removeInvalidParentheses(s) {
    let queue = new Set([s]);
    while (queue.size) {
        const next = new Set();
        for (let v of queue) {
            if (isValid(v)) {
                return [...queue].filter(isValid);
            }

            for (let i = 0; i &lt; v.length; i++) {
                next.add(v.slice(0, i) + v.slice(i + 1));
            }
        }
        queue = next;
    }
    return [''];
}

function isValid(str) {
    let bal = 0;
    for (let ch of str) {
        if (ch === '(') {
            bal++;
        } else if (ch === ')') {
            bal--;
        }
        if (bal &lt; 0) {
            return false;
        }
    }
    return bal === 0;
}

/**

Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Example 1:

Input: &quot;()())()&quot;
Output: [&quot;()()()&quot;, &quot;(())()&quot;]
 */

 console.log(removeInvalidParentheses(&quot;(a)())()&quot;))
 console.log(removeInvalidParentheses(&quot;()()(())&quot;))
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/move-zeros.svg" alt="./examples/move-zeros.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="42---examplesnested-list-weight-sumjs">42 - ./examples/nested-list-weight-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthSumHelper</span>(<span class="hljs-params">list, depth</span>) </span>{
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">in</span> list) {
        <span class="hljs-built_in">console</span>.log(n);
        <span class="hljs-keyword">if</span> (n.isInteger()) {
            sum += n.getInteger() * depth;
        } <span class="hljs-keyword">else</span> {
            sum += depthSumHelper(n.getList(), depth + <span class="hljs-number">1</span>);
        }
    }
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthSum</span>(<span class="hljs-params">nestedList</span>) </span>{
    <span class="hljs-keyword">return</span> depthSumHelper(nestedList, <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">array, index1, index2</span>) </span>{
    <span class="hljs-keyword">var</span> aux = array[index1];
    array[index1] = array[index2];
    array[index2] = aux;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">let</span> length = array.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        <span class="hljs-built_in">console</span>.log(i, array)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
                swap(array, j, j + <span class="hljs-number">1</span>);
            }
        }
    }
    <span class="hljs-keyword">return</span> array;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort2</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">var</span> length = array.length;
    <span class="hljs-keyword">var</span> cost = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) { <span class="hljs-comment">//{1} </span>
        cost++;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) { <span class="hljs-comment">//{2} </span>
            cost++;
            <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) {
                swap(array, j, j + <span class="hljs-number">1</span>);
            }
        }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`cost for bubbleSort with input size <span class="hljs-subst">${length}</span> is <span class="hljs-subst">${cost}</span>`</span>);
}

<span class="hljs-comment">//console.log(bubbleSort([7, 2, 4, 5, 9, 8, 1, 3, 6]));</span>







</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/nested-list-weight-sum.svg" alt="./examples/nested-list-weight-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="43---examplesnumber-of-islandsjs">43 - ./examples/number-of-islands.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. 
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. 

&gt; You may assume all four edges of the grid are all surrounded by water.

Example 1:

</span></div></code></pre>
<p>Input:
11110
11010
11000
00000</p>
<p>Output: 1</p>
<pre class="hljs"><code><div>
Example 2:

</div></code></pre>
<p>Input:
11000
11000
00100
00011
['1', '1', '1', '0', '0'],
['0', '0', '1', '0', '0'],
['0', '0', '0', '1', '1']
Output: 3</p>
<pre class="hljs"><code><div>
*/
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    let count = 0;
    
    const height = grid.length;
    const width = grid[0].length;
    const visited = Array(height * width).fill(false);

    for (let i = 0; i &lt; height; i++) {
        for (let j = 0; j &lt; width; j++) {
            const col = grid[i][j];
            //console.log(col);
            if (!visited[i * width + j] &amp;&amp; grid[i][j] === 1) {
                count++;
                dfs(i, j);
            }
        }

    }

    function dfs(r, c) {
        visited[r * width + c] = true;
        let dr = [r - 1, r + 1, r, r];
        let dc = [c, c, c - 1, c + 1];
        for (let i = 0; i &lt; 4; i++) {
            if (dr[i] &gt;= 0 &amp;&amp; dr[i] &lt; height &amp;&amp; dc[i] &gt;= 0 &amp;&amp; dc[i] &lt; width &amp;&amp; grid[dr[i]][dc[i]] === 1 &amp;&amp; !visited[dr[i] * width + dc[i]]) {
                dfs(dr[i], dc[i]);
            }
        }
        return;
    }

    return count;
};


console.log(numIslands([
    []
]));
console.log(numIslands([
    [1, 1, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 1, 1]
]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/number-of-islands.svg" alt="./examples/number-of-islands.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="44---examplesone-edit-awayjs">44 - ./examples/one-edit-away.js</h2>
<pre class="hljs"><code><div>    
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/one-edit-away.svg" alt="./examples/one-edit-away.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="45---examplespascal-triangle-2js">45 - ./examples/pascal-triangle-2.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pascalTriangle</span>(<span class="hljs-params">lineNumber</span>) </span>{
    <span class="hljs-keyword">const</span> currentLine = [<span class="hljs-number">1</span>];
    <span class="hljs-keyword">const</span> currentLineSize = lineNumber + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> numIndex = <span class="hljs-number">1</span>; numIndex &lt; currentLineSize; numIndex += <span class="hljs-number">1</span>) {
      currentLine[numIndex] = currentLine[numIndex - <span class="hljs-number">1</span>] * (lineNumber - numIndex + <span class="hljs-number">1</span>) / numIndex;
    }
    <span class="hljs-keyword">return</span> currentLine;
  }
  <span class="hljs-comment">/**
   * @param {number} rowIndex
   * @return {number[]}
   */</span>
  <span class="hljs-keyword">var</span> getRow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rowIndex</span>) </span>{
      <span class="hljs-keyword">return</span> pascalTriangle(rowIndex);
  };
  
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/pascal-triangle-2.svg" alt="./examples/pascal-triangle-2.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="46---examplespath-sumjs">46 - ./examples/path-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Path Sum
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

&gt; Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

</span></div></code></pre>
<pre><code>  5
 / \
4   8
</code></pre>
<p>/   / <br>
11  13  4
/  \      <br>
7    2      1</p>
<pre class="hljs"><code><div>return `true`, as there exist a root-to-leaf path `5-&gt;4-&gt;11-&gt;2` which sum is `22`.

*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * Time Complexity: O(n)
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    let node = root;
    if(!node){
        return false;
    }
    if(node === null){
        return (sum === 0);
    }
    let answer = false;
    let subsum = sum - node.val;
    if(subsum === 0 &amp;&amp; node.left == null &amp;&amp; node.right == null){
        return true;
    } 
    if(node.left !== null){
       answer = answer || hasPathSum(node.left, subsum);
    }
    if(node.right !== null){
       answer = answer || hasPathSum(node.right, subsum);
    }
    return answer;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/path-sum.svg" alt="./examples/path-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="47---examplespermutationsjs">47 - ./examples/permutations.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
# Permutations

Given a collection of distinct integers, return all possible permutations.

Example:

</span></div></code></pre>
<p>Input: [1,2,3]
Output:
[
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]</p>
<pre class="hljs"><code><div>
*/
const permute = function (nums) {
    if (nums.length &lt;= 1) {
        return [nums]
    }
    let res = []
    let last = nums.pop()
    let prevPerms = permute(nums)
    for (let prevPerm of prevPerms) {
        for (let i = 0; i &lt;= prevPerm.length; i++) {
            let clone = prevPerm.slice(0)
            clone.splice(i, 0, last)
            res.push(clone)
        }
    }
    return res;
}

console.log(permute([1, 2, 3]))
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/permutations.svg" alt="./examples/permutations.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="48---examplespivot-indexjs">48 - ./examples/pivot-index.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
     <span class="hljs-comment">// Run through all the numbers in the array</span>
    <span class="hljs-keyword">for</span> (; i &lt; nums.length; i++) {

        <span class="hljs-comment">// Get the sum on either half of the potential pivot</span>
        <span class="hljs-keyword">let</span> leftSum = nums.slice(<span class="hljs-number">0</span>, i).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">let</span> rightSum = nums.slice(i+<span class="hljs-number">1</span>).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>)

        <span class="hljs-comment">// Check if pivot</span>
        <span class="hljs-keyword">if</span> (leftSum === rightSum) { <span class="hljs-keyword">return</span> i; }
    }

    <span class="hljs-comment">// If we have run through the whole array and not found a pivot then return -1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
};

<span class="hljs-built_in">console</span>.log(pivotIndex([<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/pivot-index.svg" alt="./examples/pivot-index.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="49---examplesplus-onejs">49 - ./examples/plus-one.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * ## Plus One
 * @param {number[]} digits
 * @return {number[]}
 */</span>
<span class="hljs-keyword">var</span> plusOne = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">digits</span>) </span>{    
    <span class="hljs-keyword">let</span> i = digits.length;
    <span class="hljs-keyword">while</span> (i--) {
        digits[i] = (digits[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;
        <span class="hljs-keyword">if</span> (digits[i] &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> digits;
        }
    }
    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, ...digits];
  };
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/plus-one.svg" alt="./examples/plus-one.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="50---examplesread-n-characters-given-read4js">50 - ./examples/read-n-characters-given-read4.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * Definition for read4()
 * 
 * @param {character[]} buf Destination buffer
 * @return {number} The number of characters read
 * read4 = function(buf) {
 *     ...
 * };
 */</span>

<span class="hljs-comment">/**
 * @param {function} read4()
 * @return {function}
 */</span>
<span class="hljs-keyword">var</span> solution = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">read4</span>) </span>{
    <span class="hljs-keyword">var</span> internalBuf = [];

    <span class="hljs-comment">/**
     * @param {character[]} buf Destination buffer
     * @param {number} n Maximum number of characters to read
     * @return {number} The number of characters read
     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">buf, n</span>) </span>{
        <span class="hljs-keyword">let</span> readChars = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (internalBuf.length === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (read4(internalBuf) === <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> readChars;
                }
            }

            buf.push(internalBuf.shift());
            readChars++;
            n--;
        }
        <span class="hljs-keyword">return</span> readChars;
    };
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/read-n-characters-given-read4.svg" alt="./examples/read-n-characters-given-read4.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="51---examplesremove-duplicatesjs">51 - ./examples/remove-duplicates.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (!nums || !nums.length) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    }
    <span class="hljs-keyword">let</span> newIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> p2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> len = nums.length;

    <span class="hljs-comment">//while p1 &lt; length</span>
    <span class="hljs-keyword">while</span> (p1 &lt; len) {
        <span class="hljs-comment">// console.log(p1, p2);</span>
        <span class="hljs-keyword">while</span> (p2 &lt; len &amp;&amp; nums[p1] == nums[p2]) {
            p2 += <span class="hljs-number">1</span>;

        }
        nums[newIndex] = nums[p1];
        newIndex += <span class="hljs-number">1</span>
        p1 = p2;
    }

    <span class="hljs-keyword">return</span> newIndex;
};
<span class="hljs-built_in">console</span>.time(<span class="hljs-string">'removeDuplicates'</span>);
<span class="hljs-built_in">console</span>.log(removeDuplicates([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]))
<span class="hljs-built_in">console</span>.log(removeDuplicates([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'removeDuplicates'</span>);
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/remove-duplicates.svg" alt="./examples/remove-duplicates.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="52---examplesremove-elementjs">52 - ./examples/remove-element.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> removeElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, val</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (nums[i] === val) {
            nums.splice(i, <span class="hljs-number">1</span>);
            i--;
        }
    }

    <span class="hljs-keyword">return</span> nums.length;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/remove-element.svg" alt="./examples/remove-element.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="53---examplesremove-invalid-parenthesesjs">53 - ./examples/remove-invalid-parentheses.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openBrace</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'('</span>].includes(s)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeBrace</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> [<span class="hljs-string">')'</span>].includes(s)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeInvalidParentheses</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([s]);
    <span class="hljs-keyword">while</span> (queue.size) {
        <span class="hljs-keyword">const</span> next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> queue) {
            <span class="hljs-keyword">if</span> (isValid(v)) {
                <span class="hljs-keyword">return</span> [...queue].filter(isValid);
            }

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; v.length; i++) {
                next.add(v.slice(<span class="hljs-number">0</span>, i) + v.slice(i + <span class="hljs-number">1</span>));
            }
        }
        queue = next;
    }
    <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> bal = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> str) {
        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">'('</span>) {
            bal++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">')'</span>) {
            bal--;
        }
        <span class="hljs-keyword">if</span> (bal &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> bal === <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/**
 * @param {string} s
 * @return {string[]}
 */</span>
<span class="hljs-keyword">var</span> removeInvalidParentheses2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> dict = {
        <span class="hljs-string">'{'</span>: <span class="hljs-string">'}'</span>,
        <span class="hljs-string">'('</span>: <span class="hljs-string">')'</span>,
        <span class="hljs-string">'['</span>: <span class="hljs-string">']'</span>
    };
    <span class="hljs-keyword">let</span> stack = [];
    <span class="hljs-keyword">let</span> input = s.split(<span class="hljs-string">''</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closesMostRecentBrace</span>(<span class="hljs-params">char</span>) </span>{
        <span class="hljs-built_in">console</span>.log(s[s.length - <span class="hljs-number">1</span>])
        <span class="hljs-keyword">return</span> (s[s.length - <span class="hljs-number">1</span>] === char);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++) {
        <span class="hljs-keyword">const</span> char = input[i];

        <span class="hljs-comment">//​# If the character is an opening brace, we push it onto the stack:​</span>
        <span class="hljs-keyword">if</span> (openBrace(char)) {
            stack.push(char);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'open'</span>, s.length);
        }
        <span class="hljs-comment">//​# If the character closes the most recent opening brace,​</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (closeBrace(char)) {
            <span class="hljs-comment">//Pop from stack</span>
            <span class="hljs-keyword">if</span> (closesMostRecentBrace(char)) {
                stack.pop();
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'closed'</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//# if the character does NOT close the most recent opening brace​</span>
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'the character does NOT close the most recent opening brace​'</span>);

            }
        }
    }
    <span class="hljs-built_in">console</span>.log(stack);
    <span class="hljs-built_in">console</span>.log(input);
};

<span class="hljs-built_in">console</span>.log(removeInvalidParentheses(<span class="hljs-string">"(b)(c))"</span>));
<span class="hljs-built_in">console</span>.log(removeInvalidParentheses2(<span class="hljs-string">"(b)(c))"</span>));
<span class="hljs-comment">//console.log(removeInvalidParentheses("()())()"));</span>
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/remove-invalid-parentheses.svg" alt="./examples/remove-invalid-parentheses.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="54---examplesremove-nth-node-from-end-of-listjs">54 - ./examples/remove-nth-node-from-end-of-list.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>
<span class="hljs-comment">/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */</span>
<span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, n</span>) </span>{
    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;

    <span class="hljs-keyword">let</span> p1 = head;
    <span class="hljs-keyword">let</span> p2 = head
    <span class="hljs-keyword">while</span> (n--) {
        <span class="hljs-keyword">if</span> (p2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        p2 = p2.next
    }
    <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2.next) {
        p1 = p1.next
        p2 = p2.next
    }
    <span class="hljs-keyword">let</span> removed = p1.next
    p1.next = removed.next
    removed.next = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">return</span> head
};

<span class="hljs-keyword">const</span> removeNthFromEnd2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">head, n</span>) </span>{
    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head;

    <span class="hljs-keyword">let</span> prev = head;
    <span class="hljs-keyword">let</span> curr = head.next;

    <span class="hljs-keyword">while</span> (curr) {
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
            n -= <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            prev = prev.next;
        }
        curr = curr.next;
    }

    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head.next;

    prev.next = prev.next.next || <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> head;
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/remove-nth-node-from-end-of-list.svg" alt="./examples/remove-nth-node-from-end-of-list.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="55---examplesreverse-words-2js">55 - ./examples/reverse-words-2.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 
Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:
Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"

Note: In the string, each word is separated by single space and there will not be any extra space in the string.
 * @param {*} str 
 */</span>
<span class="hljs-keyword">var</span> reverseWords2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> output = [];
    <span class="hljs-keyword">let</span> words = str.split(<span class="hljs-string">' '</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; words.length; index++) {
        <span class="hljs-keyword">let</span> word = words[index];
        <span class="hljs-keyword">let</span> temp = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = word.length - <span class="hljs-number">1</span>; index &gt; <span class="hljs-number">-1</span>; index--) {
            <span class="hljs-keyword">let</span> w = word[index];
            temp.push(w);
        }
        output.push(temp.join(<span class="hljs-string">''</span>));
    }
    <span class="hljs-keyword">return</span> output.join(<span class="hljs-string">' '</span>);
};
<span class="hljs-built_in">console</span>.log(reverseWords2(<span class="hljs-string">"Let's take LeetCode contest"</span>) === <span class="hljs-string">"s'teL ekat edoCteeL tsetnoc"</span>);
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/reverse-words-2.svg" alt="./examples/reverse-words-2.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="56---examplesreverse-wordsjs">56 - ./examples/reverse-words.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * Given an input string, reverse the string word by word.

Example:  

Input: "the sky is blue",
Output: "blue is sky the".
 */</span>

<span class="hljs-comment">/**
 * @param {string} str
 * @returns {string}
 */</span>
<span class="hljs-keyword">var</span> reverseWords = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> output = [];
    <span class="hljs-keyword">let</span> words = str.split(<span class="hljs-string">' '</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = words.length - <span class="hljs-number">1</span>; index &gt; <span class="hljs-number">-1</span>; index--) {
        <span class="hljs-keyword">let</span> word = words[index];
        <span class="hljs-keyword">if</span> (word) {
            <span class="hljs-comment">//console.log(word);</span>
            output.push(word);
        }
    }
    <span class="hljs-keyword">return</span> output.join(<span class="hljs-string">' '</span>);
};

<span class="hljs-built_in">console</span>.log(reverseWords(<span class="hljs-string">'the sky is blue'</span>));
<span class="hljs-built_in">console</span>.log(reverseWords(<span class="hljs-string">' the sky is blue '</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/reverse-words.svg" alt="./examples/reverse-words.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="57---examplesroman-to-integerjs">57 - ./examples/roman-to-integer.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Symbol       Value</span>
<span class="hljs-comment">// I             1</span>
<span class="hljs-comment">// V             5</span>
<span class="hljs-comment">// X             10</span>
<span class="hljs-comment">// L             50</span>
<span class="hljs-comment">// C             100</span>
<span class="hljs-comment">// D             500</span>
<span class="hljs-comment">// M             1000</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// I can be placed before V (5) and X (10) to make 4 and 9.</span>
<span class="hljs-comment">// X can be placed before L (50) and C (100) to make 40 and 90.</span>
<span class="hljs-comment">// C can be placed before D (500) and M (1000) to make 400 and 900.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: "III"</span>
<span class="hljs-comment">// Output: 3</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: "IV"</span>
<span class="hljs-comment">// Output: 4</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 3:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: "IX"</span>
<span class="hljs-comment">// Output: 9</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 4:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: "LVIII"</span>
<span class="hljs-comment">// Output: 58</span>
<span class="hljs-comment">// Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 5:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: "MCMXCIV"</span>
<span class="hljs-comment">// Output: 1994</span>
<span class="hljs-comment">// Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span>

<span class="hljs-comment">/**
 * @param {string} s
 * @return {number}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">romanToInt</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">const</span> map = {
        <span class="hljs-attr">I</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">V</span>: <span class="hljs-number">5</span>,
        <span class="hljs-attr">X</span>: <span class="hljs-number">10</span>,
        <span class="hljs-attr">L</span>: <span class="hljs-number">50</span>,
        <span class="hljs-attr">C</span>: <span class="hljs-number">100</span>,
        <span class="hljs-attr">D</span>: <span class="hljs-number">500</span>,
        <span class="hljs-attr">M</span>: <span class="hljs-number">1000</span>
    };

    <span class="hljs-keyword">let</span> prevNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> s) {
        <span class="hljs-keyword">const</span> num = map[c];

        sum = prevNum &gt;= num ?
            sum + num :
            sum + num - prevNum * <span class="hljs-number">2</span>;

        prevNum = num;
    }

    <span class="hljs-keyword">return</span> sum;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/roman-to-integer.svg" alt="./examples/roman-to-integer.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="58---examplesrotate-arrayjs">58 - ./examples/rotate-array.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>{
    nums.unshift.apply(nums, nums.splice(nums.length - k, k))

};
<span class="hljs-comment">//console.log(rotate([-1], 2))</span>
<span class="hljs-comment">//console.log(rotate([1,2,3], 4))</span>






<span class="hljs-comment">/**
 * Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
*/</span>


<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> d = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> data = [];
<span class="hljs-comment">//console.log(reverseWords2("Let's take LeetCode contest"));</span>

<span class="hljs-comment">//Solution using array.shift()</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResultsUsingArrayShift</span>(<span class="hljs-params">data, d</span>) </span>{
    <span class="hljs-keyword">let</span> temp = data.slice(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; d - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">let</span> first = temp.shift();
        temp.push(first);
    }
    <span class="hljs-keyword">return</span> temp;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rotateArray</span>(<span class="hljs-params">a, d</span>) </span>{
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> size = a.length;
    <span class="hljs-keyword">let</span> rotations = d - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> a.reduce(<span class="hljs-function">(<span class="hljs-params">arr, number</span>) =&gt;</span> {
        arr[(i + (size - rotations)) % size] = number;
        i++;
        <span class="hljs-keyword">return</span> arr;
    }, [])
}
<span class="hljs-built_in">console</span>.log(rotateArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">5</span>));
<span class="hljs-built_in">console</span>.log(rotateArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">2</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/rotate-array.svg" alt="./examples/rotate-array.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="59---examplesserialize-and-deserialize-binary-treejs">59 - ./examples/serialize-and-deserialize-binary-tree.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Serialize and Deserialize Binary Tree

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example: 

</span></div></code></pre>
<p>You may serialize the following tree:</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   3
/ <br>
4   5</p>
<p>as &quot;[1,2,3,null,null,4,5]&quot;</p>
<pre class="hljs"><code><div>
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

&gt; Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
    let str = '';
    let buildString = function(node) {
        if (!node) {
            str += '# ';
            return;
        }
        str += node.val + ' ';
        buildString(node.left);
        buildString(node.right);
        
    }
    buildString(root);
    return str;
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    let values = data.split(' '), len = values.length, idx = 0;
    let buildTree = function() {
        if (idx &gt;= len || values[idx] === '#') {
            return null;
        }
        let node = new TreeNode(parseInt(values[idx]));
        ++idx;
        node.left = buildTree();
        ++idx;
        node.right = buildTree();
        return node;
    }
    return buildTree();
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/serialize-and-deserialize-binary-tree.svg" alt="./examples/serialize-and-deserialize-binary-tree.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="60---examplesset-matrix-zerosjs">60 - ./examples/set-matrix-zeros.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Set Matrix Zeroes

Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

</span></div></code></pre>
<p>Input:
[
[1,1,1],
[1,0,1],
[1,1,1]
]
Output:
[
[1,0,1],
[0,0,0],
[1,0,1]
]</p>
<pre class="hljs"><code><div>
*/
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {
    let rowHasZero = false;
    let colHasZero = false;

    let rows = [];
    let cols = [];

    function nullifyRow(matrix, row) {
        for (let index = 0; index &lt; matrix.length; index++) {
            matrix[row][index] = 0;
        }
    }

    function nullifyCol(matrix, col) {
        for (let index = 0; index &lt; matrix.length; index++) {
            matrix[index][col] = 0;
        }
    }

    //check if first row has 0
    for (let j = 0; j &lt; matrix[0].length; j++) {
        if (matrix[0][j] === 0) {
            rowHasZero = true;
            break;
        }
    }
    //check if first col has 0
    for (let i = 0; i &lt; matrix.length; i++) {
        if (matrix[i][0] === 0) {
            colHasZero = true;
            break;
        }
    }

    // check for zeros in rest of array
    for (let i = 1; i &lt; matrix.length; i++) {
        for (let j = 1; j &lt; matrix[0].length; j++) {
            if (matrix[i][j] === 0) {
                rows[i] = true;
                cols[j] = true;
            } 
        }    
    }
    
      // Nullify rows
      for (let i = 1; i &lt; matrix.length; i++) {
        if (matrix[i][0] === 0) {
            nullifyRow(matrix, i);
        }
    }
    // Nullify cols
    for (let j = 1; j &lt; matrix[0].length; j++) {
        if (matrix[0][j] === 0) {
            nullifyCol(matrix, j);
        }
    }

    if(rowHasZero){
        nullifyRow(matrix, 0)
    }
    if(colHasZero){
        nullifyCol(matrix, 0)
    }
    return matrix;
};

console.log(
    setZeroes([
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1]
    ])
);
console.log(
    setZeroes([
        [0,1,2,0],
        [3,4,5,2],
        [1,3,1,5]
      ])
);
var solution = function(isBadVersion) {
    /**
      * @param {integer} n Total versions
      * @return {integer} The first bad version
      */
     return function(n) {
         var min = 1;
         var max = n;
         var bad = -1;
         while (min &lt;= max) {
             var mid = Math.floor((min+max)/2);
             if (isBadVersion(mid)) {
                 bad = mid;
                 max = mid-1;
             }
             else {
                 min = mid+1;
             }
         }
         return bad;
     };
 };

 console.log(solution(5)())
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/set-matrix-zeros.svg" alt="./examples/set-matrix-zeros.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="61---examplessingle-numberjs">61 - ./examples/single-number.js</h2>
<pre class="hljs"><code><div>    
<span class="hljs-comment">/**
 * 

 ## Single Number
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

&gt; Note: Your algorithm should have a linear runtime complexity O(n). 

#### Example 1:

</span></div></code></pre>
<p>Input: [2,2,1]
Output: 1</p>
<pre class="hljs"><code><div>
#### Example 2:

</div></code></pre>
<p>Input: [4,1,2,1,2]
Output: 4</p>
<pre class="hljs"><code><div>*/
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    for (let i = 0; i &lt; nums.length; i++) {
        let n1 = nums[i];
        if (nums.indexOf(n1) === nums.lastIndexOf(n1)) {
            return n1;
        }
    }
};

console.log(singleNumber([2, 2, 1]));
//console.log(singleNumber([4,1,2,1,2]));
console.log(singleNumber([1,1,1,1,1,5]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/single-number.svg" alt="./examples/single-number.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="62---examplessorted-array-to-bstjs">62 - ./examples/sorted-array-to-bst.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Given the sorted array: [-10,-3,0,5,9],</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//       0</span>
<span class="hljs-comment">//      / \</span>
<span class="hljs-comment">//    -3   9</span>
<span class="hljs-comment">//    /   /</span>
<span class="hljs-comment">//  -10  5</span>

<span class="hljs-comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="hljs-comment">/**
 * @param {number[]} nums
 * @return {TreeNode}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortedArrayToBST</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);
    node.left = sortedArrayToBST(nums.slice(<span class="hljs-number">0</span>, mid));
    node.right = sortedArrayToBST(nums.slice(mid + <span class="hljs-number">1</span>)); <span class="hljs-comment">// make sure + 1, because mid number is root node, so need skip it</span>

    <span class="hljs-keyword">return</span> node;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/sorted-array-to-bst.svg" alt="./examples/sorted-array-to-bst.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="63---examplesspiral-orderjs">63 - ./examples/spiral-order.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*  
k - starting row index
m - ending row index
l - starting column index
n - ending column index
i - iterator
*/</span>
<span class="hljs-comment">/**
 * @param {number[][]} matrix
 * @return {number[]}
 */</span>
<span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];
     <span class="hljs-keyword">if</span> (!matrix.length) {
         <span class="hljs-keyword">return</span> result;
     }
     <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
         a = matrix,
         m = matrix.length,
         n = matrix[<span class="hljs-number">0</span>].length,
         k = <span class="hljs-number">0</span>,
         l = <span class="hljs-number">0</span>;
 
     <span class="hljs-keyword">while</span> (k &lt; m &amp;&amp; l &lt; n) {
         <span class="hljs-comment">//first row</span>
         <span class="hljs-keyword">for</span> (i = l; i &lt; n; ++i) {
             result.push(a[k][i]);
         }
         k++;
         <span class="hljs-comment">//last column</span>
         <span class="hljs-keyword">for</span> (i = k; i &lt; m; ++i) {
             result.push(a[i][n - <span class="hljs-number">1</span>]);
         }
         n--;
         <span class="hljs-comment">// Print the last row from the remaining rows </span>
         <span class="hljs-keyword">if</span> (k &lt; m) {
             <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= l; --i) {
                 result.push(a[m - <span class="hljs-number">1</span>][i]);
             }
             m--;
         }
         <span class="hljs-comment">// Print the first column from the remaining columns </span>
         <span class="hljs-keyword">if</span> (l &lt; n) {
             <span class="hljs-keyword">for</span> (i = m - <span class="hljs-number">1</span>; i &gt;= k; --i) {
                 result.push(a[i][l]);
             }
             l++;
         }
     }
     <span class="hljs-keyword">return</span> result;
 };
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/spiral-order.svg" alt="./examples/spiral-order.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="64---examplesstr-strjs">64 - ./examples/str-str.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">// Implement strStr().</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 1:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: haystack = "hello", needle = "ll"</span>
<span class="hljs-comment">// Output: 2</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Example 2:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Input: haystack = "aaaaa", needle = "bba"</span>
<span class="hljs-comment">// Output: -1</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Clarification:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// What should we return when needle is an empty string? This is a great question to ask during an interview.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</span>


<span class="hljs-comment">/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */</span>
<span class="hljs-keyword">var</span> strStr = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">haystack, needle</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (needle === <span class="hljs-string">""</span>) {
    <span class="hljs-keyword">return</span> result;
  }
  <span class="hljs-keyword">let</span> index = haystack.indexOf(needle);
  <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">-1</span> ? index : result;
};

<span class="hljs-comment">/** 1) Cheating */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strStr1</span>(<span class="hljs-params">haystack, needle</span>) </span>{
  <span class="hljs-keyword">return</span> haystack.indexOf(needle);
}

<span class="hljs-comment">/** 2) Brute force */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strStr2</span>(<span class="hljs-params">haystack, needle</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; haystack.length - needle.length + <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">if</span> (haystack.substr(i, needle.length) === needle) <span class="hljs-keyword">return</span> i;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/str-str.svg" alt="./examples/str-str.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="65---examplessub-setsjs">65 - ./examples/sub-sets.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

</span></div></code></pre>
<p>Input: nums = [1,2,3]
Output:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]</p>
<pre class="hljs"><code><div> */
const subsets = function (nums) {
    const res = [
        []
    ];
    if (nums.length === 0 || nums === null) {
        return res;
    }
    const len = nums.length;

    function helper(i, arr = []) {
        for (; i &lt; len; i++) {
            let clone = arr.slice(0);
            clone.push(nums[i]);
            res.push(clone);
            if (i + 1 &lt; len) {
                helper(i + 1, clone);
            }
        }
    }
    helper(0);
    return res;
}

console.log(subsets([1, 2, 3]));
console.log(subsets([1, 2]));




/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
    let hashTable = {
        2: 'abc',
        3: 'def',
        4: 'ghi',
        5: 'jkl',
        6: 'mno',
        7: 'pqrs',
        8: 'tuv',
        9: 'wxyz'
    };
    let output = [];

    function helper(digit, n) {
        if (digit === n) {
            return;
        }
        for (let i = 0; i &lt; hashTable[digit].length; i++) {
            let curr = hashTable[digit][i];
            console.log(curr);
            output.push(hashTable[digit][i])
        }
    }
    digits.split('').forEach(d =&gt; {
        console.log(helper(d));
    })
    return output;
};

</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/sub-sets.svg" alt="./examples/sub-sets.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="66---examplesthree-sumjs">66 - ./examples/three-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="hljs-keyword">var</span> threeSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>{
    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

    <span class="hljs-keyword">let</span> results = [];
    <span class="hljs-keyword">let</span> totalSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (i &lt; nums.length - <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> k = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (j &lt; k) {
            <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[k]
            <span class="hljs-keyword">if</span> (sum &lt; totalSum) {
                <span class="hljs-keyword">while</span> (nums[++j] === nums[j - <span class="hljs-number">1</span>]);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; totalSum) {
                <span class="hljs-keyword">while</span> (nums[--k] === nums[k + <span class="hljs-number">1</span>]);
            } <span class="hljs-keyword">else</span> {
                results.push([nums[i], nums[j], nums[k]])
                <span class="hljs-keyword">while</span> (nums[++j] === nums[j - <span class="hljs-number">1</span>]);
                <span class="hljs-keyword">while</span> (nums[--k] === nums[k + <span class="hljs-number">1</span>]);
            }
        }
        <span class="hljs-keyword">while</span> (nums[++i] === nums[i - <span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">return</span> results;
};
<span class="hljs-built_in">console</span>.log(threeSum([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>]));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/three-sum.svg" alt="./examples/three-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="67---examplestree-populate-next-pointerjs">67 - ./examples/tree-populate-next-pointer.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/*
## Populating Next Right Pointers in Each Node
Given a binary tree

</span></div></code></pre>
<p>struct TreeLinkNode {
TreeLinkNode *left;
TreeLinkNode *right;
TreeLinkNode *next;
}</p>
<pre class="hljs"><code><div>
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

- You may only use constant extra space.
- Recursive approach is fine, implicit stack space does not count as extra space for this problem.
- You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

Example:

Given the following perfect binary tree,

</div></code></pre>
<pre><code> 1
</code></pre>
<p>/  <br>
2    3
/ \  / <br>
4  5  6  7</p>
<pre class="hljs"><code><div>
After calling your function, the tree should look like:

</div></code></pre>
<pre><code> 1 -&gt; NULL
</code></pre>
<p>/  <br>
2 -&gt; 3 -&gt; NULL
/ \  / <br>
4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
<pre class="hljs"><code><div>*/
/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */

var connect = function(root) {
    if(!root) return;
    const queue = [root];
    
    while(queue.length) {
        const size  = queue.length;
        const level = queue.slice();

        for(let i = 0; i &lt; size; i++) {
            const currentNode = queue.shift();
            currentNode.next  = level[i + 1];
            if(currentNode.left)  queue.push(currentNode.left);
            if(currentNode.right) queue.push(currentNode.right);
        }
    }
};
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/tree-populate-next-pointer.svg" alt="./examples/tree-populate-next-pointer.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="68---examplestree-preorder-traversaljs">68 - ./examples/tree-preorder-traversal.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">this</span>.val = val;
    <span class="hljs-keyword">this</span>.left = <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>;
}
<span class="hljs-comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="hljs-comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];
    traversal(root);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span>(<span class="hljs-params">root</span>) </span>{
        <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> result;
        } <span class="hljs-keyword">else</span> {
            result.push(root.val);
            traversal(root.left);
            traversal(root.right);
        }
    };
    <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];
    traversal(root);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traversal</span>(<span class="hljs-params">root</span>) </span>{
        <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> result;
        } <span class="hljs-keyword">else</span> {
            traversal(root.left);
            traversal(root.right);
            result.push(root.val);
        }
    };
    <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">100</span>);
root.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>);
root.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">7</span>);
root.right.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);
root.right.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">6</span>);
root.left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);
root.left.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);
root.left.left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">8</span>);

<span class="hljs-comment">//const {BinarySearchTree} = require('../src/index');</span>


<span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">let</span> left_depth = maxDepth(root.left);
    <span class="hljs-keyword">let</span> right_depth = maxDepth(root.right);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left_depth, right_depth) + <span class="hljs-number">1</span>;
};

<span class="hljs-comment">//console.log(preorderTraversal(root));</span>
<span class="hljs-comment">//console.log(postorderTraversal(root));</span>
<span class="hljs-comment">//console.log(maxDepth(root));</span>

<span class="hljs-comment">/**
 * @param {number} x
 * @return {number}
 */</span>
<span class="hljs-keyword">var</span> reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">let</span> out = [];
    <span class="hljs-keyword">let</span> parts = <span class="hljs-built_in">String</span>(x).split(<span class="hljs-string">''</span>);
    <span class="hljs-keyword">let</span> j = parts.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> isNegative = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (; i &lt; parts.length; i++) {
        <span class="hljs-keyword">if</span> (parts[i] !== <span class="hljs-string">'-'</span>) {
            out[j] = parts[i];
            isNegative = <span class="hljs-literal">false</span>;
        }
        j--;
    }


    <span class="hljs-built_in">console</span>.log(parts, out.join(<span class="hljs-string">''</span>));

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(out.join(<span class="hljs-string">''</span>));
};
<span class="hljs-comment">/**
## Reverse Integer
Given a 32-bit signed integer, reverse digits of an integer.

#### Example 1:

Input: 123
Output: 321

#### Example 2:

Input: -123
Output: -321

#### Example 3:

Input: 120
Output: 21
 */</span>
<span class="hljs-keyword">var</span> reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">const</span> reversedInt = +<span class="hljs-built_in">String</span>(<span class="hljs-built_in">Math</span>.abs(x)).split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>);
    <span class="hljs-keyword">return</span> reversedInt &lt; <span class="hljs-number">0x7FFFFFFF</span> ? <span class="hljs-built_in">Math</span>.sign(x) * reversedInt : <span class="hljs-number">0</span>;
};
<span class="hljs-built_in">console</span>.log(reverse(<span class="hljs-number">123</span>));
<span class="hljs-built_in">console</span>.log(reverse(<span class="hljs-number">-123</span>));
<span class="hljs-comment">//console.assert(reverse(123) === 321);</span>


<span class="hljs-comment">/*
## First Unique Character in a String
Given a string, find the first non-repeating character in it and return it's index. 
If it doesn't exist, return -1.

Examples:

s = "leetcode"
return 0.

s = "loveleetcode",
return 2.

&gt; Note: You may assume the string contain only lowercase letters.
*/</span>
<span class="hljs-comment">/**
 * @param {string} s
 * @return {number}
 */</span>
<span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">var</span> map = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
        <span class="hljs-keyword">let</span> key = s[i];
        <span class="hljs-keyword">if</span> (map[key] === <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// if letter hasn't been encountered </span>
            <span class="hljs-comment">// set char as key and value ([index, count]) as tuple of the index and letter count</span>
            map[key] = [i, <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// increment letter count</span>
            map[key][<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;
            <span class="hljs-built_in">console</span>.log(key, i)
        }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> map) {
        <span class="hljs-built_in">console</span>.log(k, map[k]);
        <span class="hljs-comment">// if a character count is equal to 1 it is the first unique, so return</span>
        <span class="hljs-keyword">if</span> (map[k][<span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> map[k][<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// return -1 if we didnt find a unique in our map</span>
};
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'abc'</span>));
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'aba'</span>));
<span class="hljs-built_in">console</span>.log(firstUniqChar(<span class="hljs-string">'loveleetcode'</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/tree-preorder-traversal.svg" alt="./examples/tree-preorder-traversal.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="69---examplestwo-sumjs">69 - ./examples/two-sum.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**

## Two Sum

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */</span>
<span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">numbers, target</span>) </span>{
    <span class="hljs-keyword">let</span> dict = {};
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> numbers) {
        <span class="hljs-keyword">if</span> (target - numbers[i] <span class="hljs-keyword">in</span> dict) {
            <span class="hljs-keyword">return</span> [dict[target - numbers[i]] + <span class="hljs-number">1</span>, <span class="hljs-built_in">Number</span>(i) + <span class="hljs-number">1</span>];
        }
        dict[numbers[i]] = <span class="hljs-built_in">Number</span>(i);
    }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum1</span>(<span class="hljs-params">nums, target</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++) {
            <span class="hljs-keyword">if</span> (i === j) <span class="hljs-keyword">continue</span>;

            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) <span class="hljs-keyword">return</span> [i, j];
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>{
    <span class="hljs-keyword">let</span> map = {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">const</span> diff = target - nums[i];

        <span class="hljs-keyword">if</span> (map[diff] !== <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> [map[diff], i];
        map[nums[i]] = i;
    }
}
<span class="hljs-built_in">console</span>.log(twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>));
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/two-sum.svg" alt="./examples/two-sum.js-svg image" title="Logo Title Text 2"></p>
<hr>
<h2 id="70---examplesvalid-paramsjs">70 - ./examples/valid-params.js</h2>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> c;
    <span class="hljs-keyword">let</span> dict = {
      <span class="hljs-string">'{'</span>: <span class="hljs-string">'}'</span>,
      <span class="hljs-string">'('</span>: <span class="hljs-string">')'</span>,
      <span class="hljs-string">'['</span>: <span class="hljs-string">']'</span>
    };
    <span class="hljs-keyword">let</span> stack = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
      c = s[i];
      <span class="hljs-keyword">if</span> (dict[c]) {
        stack.push(c);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (dict[stack.pop()] !== c) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> (stack.length === <span class="hljs-number">0</span>);
  };
</div></code></pre>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/jonniespratley/js-leetcode/master/flowcharts/valid-params.svg" alt="./examples/valid-params.js-svg image" title="Logo Title Text 2"></p>
<hr>

</body>
</html>
